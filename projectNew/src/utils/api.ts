import { API_BASE_URL, API_ENDPOINTS } from './constants';
import type { APIResponse, UploadResponse } from '../types';

class APIClient {
  private baseURL: string;

  constructor(baseURL: string = API_BASE_URL) {
    this.baseURL = baseURL;
  }

  async uploadPDF(file: File, onProgress?: (progress: number) => void): Promise<UploadResponse> {
    return new Promise((resolve, reject) => {
      const formData = new FormData();
      formData.append('file', file);

      const xhr = new XMLHttpRequest();
      
      xhr.upload.onprogress = (event) => {
        if (event.lengthComputable && onProgress) {
          const progress = (event.loaded / event.total) * 100;
          onProgress(progress);
        }
      };

      xhr.onload = () => {
        if (xhr.status === 200) {
          try {
            const response = JSON.parse(xhr.responseText);
            resolve(response);
          } catch (error) {
            reject(new Error('Invalid response format'));
          }
        } else {
          reject(new Error(`Upload failed: ${xhr.status}`));
        }
      };

      xhr.onerror = () => reject(new Error('Network error during upload'));

      // Mock response for demo
      setTimeout(() => {
        resolve({
          document_id: `doc_${Date.now()}`,
          status: 'success'
        });
      }, 2000);

      // Uncomment for real API
      // xhr.open('POST', `${this.baseURL}${API_ENDPOINTS.UPLOAD_PDF}`);
      // xhr.send(formData);
    });
  }

  async analyzeText(text: string): Promise<UploadResponse> {
    // Mock implementation
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve({
          document_id: `text_${Date.now()}`,
          status: 'success'
        });
      }, 1500);
    });

    // Real implementation would be:
    // const response = await fetch(`${this.baseURL}${API_ENDPOINTS.ANALYZE_TEXT}`, {
    //   method: 'POST',
    //   headers: { 'Content-Type': 'application/json' },
    //   body: JSON.stringify({ text })
    // });
    // return response.json();
  }

  async sendQuestion(question: string, documentId: string): Promise<APIResponse> {
    const startTime = Date.now();
    
    // Mock implementation
    return new Promise((resolve) => {
      setTimeout(() => {
        const responseTime = Date.now() - startTime;
        resolve({
          answer: this.generateMockResponse(question),
          confidence: 0.85 + Math.random() * 0.1
        });
      }, 1000 + Math.random() * 2000);
    });

    // Real implementation would be:
    // const response = await fetch(`${this.baseURL}${API_ENDPOINTS.CHAT}`, {
    //   method: 'POST',
    //   headers: { 'Content-Type': 'application/json' },
    //   body: JSON.stringify({ question, document_id: documentId })
    // });
    // return response.json();
  }

  async checkHealth(): Promise<boolean> {
    try {
      // Mock implementation
      return new Promise((resolve) => {
        setTimeout(() => resolve(Math.random() > 0.1), 500);
      });

      // Real implementation would be:
      // const response = await fetch(`${this.baseURL}${API_ENDPOINTS.HEALTH}`);
      // return response.ok;
    } catch {
      return false;
    }
  }

  private generateMockResponse(question: string): string {
    const responses = [
      "Based on the document analysis, here's what I found...",
      "The document contains several key insights related to your question...",
      "From my analysis of the provided content, I can identify...",
      "The document reveals important information about...",
      "According to the text analysis, the main points include..."
    ];
    
    const randomResponse = responses[Math.floor(Math.random() * responses.length)];
    return `${randomResponse} This is a detailed response that would be generated by the AI system based on the document content. The response includes relevant information extracted from the document using RAG technology.`;
  }
}

export const apiClient = new APIClient();