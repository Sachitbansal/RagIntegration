import { API_BASE_URL, API_ENDPOINTS } from './constants';
import type { APIResponse, UploadResponse } from '../types';

class APIClient {
  private baseURL: string;

  constructor(baseURL: string = "https://long-coins-rule.loca.lt/") {
    this.baseURL = baseURL;
  }

  async uploadPDF(file: File, onProgress?: (progress: number) => void): Promise<UploadResponse> {
    return new Promise((resolve, reject) => {
      const formData = new FormData();
      formData.append('file', file);

      const xhr = new XMLHttpRequest();
      
      xhr.upload.onprogress = (event) => {
        if (event.lengthComputable && onProgress) {
          const progress = (event.loaded / event.total) * 100;
          onProgress(progress);
        }
      };

      xhr.onload = () => {
        if (xhr.status === 200) {
          try {
            const response = JSON.parse(xhr.responseText);
            resolve(response);
          } catch (error) {
            reject(new Error('Invalid response format'));
          }
        } else {
          reject(new Error(`Upload failed: ${xhr.status}`));
        }
      };

      xhr.onerror = () => reject(new Error('Network error during upload'));

      // Mock response for demo
      setTimeout(() => {
        resolve({
          document_id: `doc_${Date.now()}`,
          status: 'success'
        });
      }, 2000);

      // Uncomment for real API
      // xhr.open('POST', `${this.baseURL}${API_ENDPOINTS.UPLOAD_PDF}`);
      // xhr.send(formData);
    });
  }

  async analyzeText(text: string): Promise<UploadResponse> {
    try {
      const response = await fetch(`${this.baseURL}/upload-text`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ text })
      });
      const data = await response.json();
      if (!response.ok || !data.session_id) {
        throw new Error(data.error || 'No response from server');
      }
      return {
        document_id: data.session_id,
        status: 'success'
      };
    } catch (error: any) {
      throw new Error(error.message || 'Failed to upload text');
    }
  }

  

  async sendQuestion(question: string, documentId: string): Promise<APIResponse> {
    try {
      const response = await fetch(`${this.baseURL}/query`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ message: question, conversation_id: documentId })
      });
      const data = await response.json();
      if (!response.ok || !data.response) {
        throw new Error(data.error || 'No response from server');
      }
      return {
        answer: data.response,
        confidence: 1.0 // The backend does not return confidence, so we set a default
      };
    } catch (error: any) {
      throw new Error(error.message || 'Failed to fetch answer');
    }
  }

  async checkHealth(): Promise<boolean> {
    try {
      // Mock implementation
      return new Promise((resolve) => {
        setTimeout(() => resolve(Math.random() > 0.1), 500);
      });

      // Real implementation would be:
      // const response = await fetch(`${this.baseURL}${API_ENDPOINTS.HEALTH}`);
      // return response.ok;
    } catch {
      return false;
    }
  }

  

  private generateMockResponse(question: string): string {
    const responses = [
      "Based on the document analysis, here's what I found...",
      "The document contains several key insights related to your question...",
      "From my analysis of the provided content, I can identify...",
      "The document reveals important information about...",
      "According to the text analysis, the main points include..."
    ];
    
    const randomResponse = responses[Math.floor(Math.random() * responses.length)];
    return `${randomResponse} This is a detailed response that would be generated by the AI system based on the document content. The response includes relevant information extracted from the document using RAG technology.`;
  }
}

export const apiClient = new APIClient();